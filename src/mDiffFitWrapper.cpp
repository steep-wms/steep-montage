// This program takes an overlap pair file generated by splitOverlapTable.js
// and calls mDiffFit for the two images found in the file. It creates a
// output stats file that can be passed to mConcatFit.js to create a table
// for the rest of the Montage processes.
//
// Usage: mDiffFitWrapper -p <projectedImagesDir> -i <inputOverlapPair>
//                        -s <outputStatsFile> -o <ouputImage>
//                        -t <headerTemplate>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <unistd.h>

void usage() {
  std::cerr << "Usage: mDiffFitWrapper -p <projectedImagesDir> -i <inputOverlapPair> "
    "-s <outputStatsFile> -o <ouputImage> -t <headerTemplate>" << std::endl;
}

std::string exec(const char* cmd) {
  std::array<char, 128> buffer;
  std::string result;
  auto pipe = popen(cmd, "r");
  if (!pipe) {
    throw std::runtime_error("Could not open child process");
  }

  while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {
    result += buffer.data();
  }

  auto rc = pclose(pipe);

  if (rc != EXIT_SUCCESS) {
    // ignore expected error and write an emtpy stats file
    if (result.find("Too few pixels") != std::string::npos) {
      std::cout << result;
      result = "";
    } else {
      std::cerr << result;
      throw std::runtime_error("Could not execute child process");
    }
  } else {
    std::cout << result;

    // ignore expected error and write an emtpy stats file
    if (result.find("All pixels are blank") != std::string::npos) {
      result = "";
    }
  }
  
  return result;
}

int main(int argc, char **argv) {
  int c;
  char *projectedImagesDir = NULL;
  char *inputOverlapPair = NULL;
  char *outputStatsFile = NULL;
  char *outputImage = NULL;
  char *headerTemplate = NULL;

  // parse command line options
  while ((c = getopt(argc, argv, "p:i:s:o:t:")) != -1) {
    switch (c) {
      case 'p':
        projectedImagesDir = optarg;
        break;
      case 'i':
        inputOverlapPair = optarg;
        break;
      case 's':
        outputStatsFile = optarg;
        break;
      case 'o':
        outputImage = optarg;
        break;
      case 't':
        headerTemplate = optarg;
        break;
      default:
        usage();
        exit(1);
    }
  }

  if (projectedImagesDir == NULL || inputOverlapPair == NULL ||
      outputStatsFile == NULL || outputImage == NULL || headerTemplate == NULL) {
    usage();
    exit(1);
  }

  // read overlap pair
  std::ifstream inputOverlapPairFile;
  inputOverlapPairFile.open(inputOverlapPair);
  if (inputOverlapPairFile.fail()) {
    std::cerr << "Error opening input overlap pair" << std::endl;
    inputOverlapPairFile.close();
    exit(1);
  }

  std::string cntr1;
  std::string cntr2;
  std::string plus;
  std::string minus;
  std::getline(inputOverlapPairFile, cntr1);
  std::getline(inputOverlapPairFile, cntr2);
  std::getline(inputOverlapPairFile, plus);
  std::getline(inputOverlapPairFile, minus);

  inputOverlapPairFile.close();

  // call mDiffFit
  std::filesystem::path plusPath = projectedImagesDir;
  plusPath /= plus;
  std::filesystem::path minusPath = projectedImagesDir;
  minusPath /= minus;

  std::stringstream cmd;
  cmd << "mDiffFit " << plusPath << " " << minusPath << " " << outputImage << " " << headerTemplate;
  std::cout << cmd.str() << std::endl;
  std::string output = "";
  try {
    output = exec(cmd.str().c_str());
  } catch (std::runtime_error e) {
    std::cerr << e.what() << std::endl;
    exit(1);
  }

  // modify output
  auto bracket = output.find_last_of(']');
  if (bracket != std::string::npos) {
    std::stringstream add;
    add << ", cntr1=" << cntr1 << ", cntr2=" << cntr2;
    output.insert(bracket, add.str());
  }

  // write stats file
  std::ofstream out(outputStatsFile);
  out << output;
  out.close();

  exit(0);
}
